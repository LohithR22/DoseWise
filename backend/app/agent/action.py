# Act node - executes the planned actions
from app.agent.state import AgentState
from app.notifications.reminders import ReminderService
from app.notifications.escalation import EscalationHandler
from app.reorder.reorder_agent import ReorderAgent
from datetime import datetime
from typing import List, Dict

def execute_actions(state: AgentState) -> AgentState:
    """
    Execute actions generated by the planner and update AgentState.
    
    Supported actions:
    - REMIND: Send medication reminders
    - ESCALATE: Escalate alerts to caregivers/doctors
    - REORDER: Trigger medication reorder process
    
    Each action is logged with:
    - what action was taken
    - why it was taken
    """
    user_id = state["user_id"]
    planned_actions = state.get("actions", [])
    executed_actions = []
    
    reminder_service = ReminderService()
    escalation_handler = EscalationHandler()
    reorder_agent = ReorderAgent()
    
    for action in planned_actions:
        action_type = action.get("type", "").upper()
        
        if action_type == "REMIND":
            result = _execute_remind_action(user_id, action, reminder_service)
            executed_actions.append(result)
            
        elif action_type == "ESCALATE":
            result = _execute_escalate_action(user_id, action, escalation_handler)
            executed_actions.append(result)
            
        elif action_type == "REORDER":
            result = _execute_reorder_action(user_id, action, reorder_agent)
            executed_actions.append(result)
        else:
            executed_actions.append({
                "type": action_type,
                "status": "unknown",
                "what": f"Unknown action type: {action_type}",
                "why": "Action type not recognized",
                "timestamp": datetime.now().isoformat()
            })
    
    # Update state with executed actions
    state["actions"] = executed_actions
    state["messages"].append(f"Executed {len(executed_actions)} actions at {datetime.now().isoformat()}")
    
    return state

def _execute_remind_action(user_id: str, action: Dict, reminder_service: ReminderService) -> Dict:
    """
    Execute a REMIND action.
    
    Logs:
    - what: Reminder sent for medication X
    - why: Scheduled dose time approaching / Follow-up after missed dose
    """
    medication = action.get("medication", {})
    is_followup = action.get("is_followup", False)
    
    if is_followup:
        success = reminder_service.send_followup_reminder(user_id, medication)
        why = f"Follow-up reminder after missed dose for {medication.get('name', 'medication')}"
    else:
        success = reminder_service.send_initial_reminder(user_id, medication)
        why = f"Scheduled dose time approaching for {medication.get('name', 'medication')}"
    
    reminder_service.log_reminder(user_id, medication, is_followup, success)
    
    return {
        "type": "REMIND",
        "status": "success" if success else "failed",
        "what": f"Reminder sent for {medication.get('name', 'medication')}",
        "why": why,
        "medication_id": medication.get("id"),
        "is_followup": is_followup,
        "timestamp": datetime.now().isoformat()
    }

def _execute_escalate_action(user_id: str, action: Dict, escalation_handler: EscalationHandler) -> Dict:
    """
    Execute an ESCALATE action.
    
    Logs:
    - what: Escalated to caregiver/doctor
    - why: Missed dose persists / Abnormal vitals / Reminders ignored
    """
    reason = action.get("reason", "unknown")
    severity = action.get("severity", "medium")
    target = action.get("target", "caregiver")  # caregiver or doctor
    context = action.get("context", {})
    
    # Determine why escalation is needed
    if reason == "missed_dose":
        why = f"Missed dose persists for {context.get('medication_name', 'medication')}"
    elif reason == "abnormal_vitals":
        why = f"Abnormal vitals detected: {context.get('vital_type', 'vital')} = {context.get('value', 'N/A')}"
    elif reason == "reminders_ignored":
        why = f"Multiple reminders ignored for {context.get('medication_name', 'medication')}"
    else:
        why = f"Escalation needed: {reason}"
    
    escalation_id = escalation_handler.create_escalation(
        user_id=user_id,
        reason=reason,
        severity=severity,
        context=context
    )
    
    if target == "doctor":
        success = escalation_handler.escalate_to_doctor(user_id, escalation_id)
        what = f"Escalated to doctor (ID: {escalation_id})"
    else:
        caregiver_id = context.get("caregiver_id")
        success = escalation_handler.escalate_to_caregiver(user_id, escalation_id, caregiver_id)
        what = f"Escalated to caregiver (ID: {escalation_id})"
    
    return {
        "type": "ESCALATE",
        "status": "success" if success else "failed",
        "what": what,
        "why": why,
        "escalation_id": escalation_id,
        "severity": severity,
        "target": target,
        "timestamp": datetime.now().isoformat()
    }

def _execute_reorder_action(user_id: str, action: Dict, reorder_agent: ReorderAgent) -> Dict:
    """
    Execute a REORDER action.
    
    Logs:
    - what: Reorder initiated for medication X
    - why: Inventory below threshold (Y days remaining)
    """
    medication = action.get("medication", {})
    current_quantity = action.get("current_quantity", 0)
    threshold = action.get("threshold", 10)
    
    reorder_decision = reorder_agent.decide_reorder(
        user_id=user_id,
        medication=medication,
        current_quantity=current_quantity
    )
    
    if reorder_decision["should_reorder"]:
        reorder_request = reorder_agent.create_reorder_request(
            user_id=user_id,
            medication=medication,
            quantity=reorder_decision["suggested_quantity"]
        )
        
        return {
            "type": "REORDER",
            "status": "success",
            "what": f"Reorder initiated for {medication.get('name', 'medication')}",
            "why": f"Inventory below threshold ({current_quantity} remaining, threshold: {threshold})",
            "medication_id": medication.get("id"),
            "current_quantity": current_quantity,
            "reorder_quantity": reorder_decision["suggested_quantity"],
            "reorder_id": reorder_request.get("reorder_id"),
            "timestamp": datetime.now().isoformat()
        }
    else:
        return {
            "type": "REORDER",
            "status": "skipped",
            "what": f"Reorder not needed for {medication.get('name', 'medication')}",
            "why": f"Inventory sufficient ({current_quantity} remaining)",
            "medication_id": medication.get("id"),
            "current_quantity": current_quantity,
            "timestamp": datetime.now().isoformat()
        }

# Legacy support - maintain backward compatibility
def action_node(state: AgentState) -> AgentState:
    """
    Legacy action node - calls execute_actions internally.
    Maintained for backward compatibility.
    """
    return execute_actions(state)
