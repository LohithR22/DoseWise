# Act node: execute planned actions (REMIND, ESCALATE, REORDER)

import logging
from app.agent.state import AgentState
from app.notifications.reminders import ReminderService
from app.notifications.escalation import EscalationHandler
from app.reorder.reorder_agent import ReorderAgent
from datetime import datetime
from typing import List, Dict

logger = logging.getLogger(__name__)

def execute_actions(state: AgentState) -> AgentState:
    """
    Execute actions generated by the planner and update AgentState.
    
    Reads state["plan"] (string format: "ACTION:target\nACTION:target")
    Converts to structured actions with full context from state
    
    Supported actions:
    - REMIND: Send medication reminders
    - ESCALATE: Escalate alerts to caregivers/doctors
    - REORDER: Trigger medication reorder process
    
    Each action is logged with:
    - what action was taken
    - why it was taken
    """
    user_id = state.get("user_id", "unknown_user")
    plan_text = state.get("plan", "")
    executed_actions = []
    
    # Parse plan string into structured actions
    structured_actions = _parse_plan_to_actions(plan_text, state)
    
    if not structured_actions:
        logger.info("action: no actions to execute")
        state["action_log"] = state.get("action_log", []) + [{
            "timestamp": datetime.now().isoformat(),
            "message": "No actions planned"
        }]
        return state
    
    # Create service instances (could be moved to state for persistence)
    reminder_service = ReminderService()
    escalation_handler = EscalationHandler()
    reorder_agent = ReorderAgent()
    
    for action in structured_actions:
        action_type = action.get("type", "").upper()
        
        if action_type == "REMIND":
            result = _execute_remind_action(user_id, action, reminder_service)
            executed_actions.append(result)
            
        elif action_type == "ESCALATE":
            result = _execute_escalate_action(user_id, action, escalation_handler, state)
            executed_actions.append(result)
            
        elif action_type == "REORDER":
            result = _execute_reorder_action(user_id, action, reorder_agent)
            executed_actions.append(result)
        else:
            executed_actions.append({
                "type": action_type,
                "status": "unknown",
                "what": f"Unknown action type: {action_type}",
                "why": "Action type not recognized",
                "timestamp": datetime.now().isoformat()
            })
    
    # Update state with executed actions in action_log
    action_log = state.get("action_log", [])
    action_log.extend(executed_actions)
    state["action_log"] = action_log
    
    messages = state.get("messages", [])
    messages.append(f"Executed {len(executed_actions)} actions at {datetime.now().isoformat()}")
    state["messages"] = messages
    
    logger.info(f"action: executed {len(executed_actions)} actions")
    
    return state

def _parse_plan_to_actions(plan_text: str, state: AgentState) -> List[Dict]:
    """
    Parse plan string into structured action dicts with full context.
    
    Plan format: "REMIND:MedName\nESCALATE:reason\nREORDER:med_id"
    
    Returns list of action dicts with full medication/inventory data.
    """
    if not plan_text or not plan_text.strip():
        return []
    
    actions = []
    medications = state.get("medications", [])
    inventory = state.get("inventory", [])
    observations = state.get("observations", [])
    
    for line in plan_text.strip().split("\n"):
        if not line.strip():
            continue
            
        if ":" not in line:
            logger.warning(f"action: invalid plan line (no colon): {line}")
            continue
            
        action_type, target = line.split(":", 1)
        action_type = action_type.strip().upper()
        target = target.strip()
        
        if action_type == "REMIND":
            # Find medication by name
            medication = _find_medication_by_name(medications, target)
            if medication:
                # Determine if this is a follow-up (from missed_doses)
                is_followup = any(f"missed_doses:" in o and target in o for o in observations)
                actions.append({
                    "type": "REMIND",
                    "medication": medication,
                    "is_followup": is_followup
                })
            else:
                logger.warning(f"action: medication not found for REMIND: {target}")
                
        elif action_type == "ESCALATE":
            # Get escalation context from observations and state
            context = _build_escalation_context(target, state)
            actions.append({
                "type": "ESCALATE",
                "reason": target,
                "severity": context.get("severity", "medium"),
                "target": context.get("target", "caregiver"),
                "context": context
            })
            
        elif action_type == "REORDER":
            # Find medication/inventory by name or ID
            medication = _find_medication_by_name(medications, target)
            inventory_item = _find_inventory_item(inventory, target)
            
            if medication:
                current_quantity = inventory_item.get("quantity", 0) if inventory_item else 0
                threshold = medication.get("reorder_threshold", 10)
                
                actions.append({
                    "type": "REORDER",
                    "medication": medication,
                    "current_quantity": current_quantity,
                    "threshold": threshold
                })
            else:
                logger.warning(f"action: medication not found for REORDER: {target}")
    
    return actions

def _find_medication_by_name(medications: List[Dict], name: str) -> Dict:
    """
    Find medication in list by name or ID.
    Returns medication dict or empty dict if not found.
    """
    if not medications:
        return {"name": name, "id": name}  # Fallback
    
    for med in medications:
        med_name = med.get("name", "")
        med_id = med.get("id", "")
        if med_name == name or med_id == name or med_name.lower() == name.lower():
            return med
    
    # Fallback: create minimal medication object
    return {"name": name, "id": name}

def _find_inventory_item(inventory: List[Dict], med_name: str) -> Dict:
    """
    Find inventory item by medication name.
    Returns inventory dict or empty dict if not found.
    """
    if not inventory:
        return {}
    
    for item in inventory:
        item_name = item.get("med_name", "") or item.get("name", "")
        if item_name == med_name or item_name.lower() == med_name.lower():
            return item
    
    return {}

def _build_escalation_context(reason: str, state: AgentState) -> Dict:
    """
    Build escalation context from state based on reason.
    Extracts relevant vitals, medications, etc.
    """
    context = {
        "reason": reason,
        "severity": "medium",
        "target": "caregiver"
    }
    
    observations = state.get("observations", [])
    vitals = state.get("vitals", [])
    
    if reason == "abnormal_vitals":
        # Extract abnormal vital info from observations
        abnormal_line = next((o for o in observations if "abnormal_vitals:" in o), "")
        if abnormal_line and ":" in abnormal_line:
            vital_names = abnormal_line.split(":", 1)[1].strip()
            
            # Find the actual vital data
            if vitals and vital_names != "none":
                latest_vital = vitals[-1] if vitals else {}
                context["vital_type"] = vital_names.split(",")[0] if "," in vital_names else vital_names
                context["value"] = latest_vital.get(context["vital_type"], "N/A")
                context["severity"] = "high"
                context["target"] = "doctor"  # Abnormal vitals go to doctor
        
    elif reason == "missed_doses":
        # Extract missed medication info
        missed_line = next((o for o in observations if "missed_doses:" in o), "")
        if missed_line and ":" in missed_line:
            med_names = missed_line.split(":", 1)[1].strip()
            context["medication_name"] = med_names.split(",")[0] if "," in med_names else med_names
            context["severity"] = "medium"
            
    elif "reminders_ignored" in reason:
        context["severity"] = "medium"
        context["reminder_count"] = 3  # Placeholder
    
    return context

def _execute_remind_action(user_id: str, action: Dict, reminder_service: ReminderService) -> Dict:
    """
    Execute a REMIND action.
    
    Logs:
    - what: Reminder sent for medication X
    - why: Scheduled dose time approaching / Follow-up after missed dose
    """
    medication = action.get("medication", {})
    is_followup = action.get("is_followup", False)
    
    if is_followup:
        success = reminder_service.send_followup_reminder(user_id, medication)
        why = f"Follow-up reminder after missed dose for {medication.get('name', 'medication')}"
    else:
        success = reminder_service.send_initial_reminder(user_id, medication)
        why = f"Scheduled dose time approaching for {medication.get('name', 'medication')}"
    
    reminder_service.log_reminder(user_id, medication, is_followup, success)
    
    return {
        "type": "REMIND",
        "status": "success" if success else "failed",
        "what": f"Reminder sent for {medication.get('name', 'medication')}",
        "why": why,
        "medication_id": medication.get("id"),
        "is_followup": is_followup,
        "timestamp": datetime.now().isoformat()
    }

def _execute_escalate_action(user_id: str, action: Dict, escalation_handler: EscalationHandler, state: AgentState) -> Dict:
    """
    Execute an ESCALATE action.
    
    Logs:
    - what: Escalated to caregiver/doctor
    - why: Missed dose persists / Abnormal vitals / Reminders ignored
    """
    reason = action.get("reason", "unknown")
    severity = action.get("severity", "medium")
    target = action.get("target", "caregiver")  # caregiver or doctor
    context = action.get("context", {})
    
    # Determine why escalation is needed
    if reason == "missed_dose":
        why = f"Missed dose persists for {context.get('medication_name', 'medication')}"
    elif reason == "abnormal_vitals":
        why = f"Abnormal vitals detected: {context.get('vital_type', 'vital')} = {context.get('value', 'N/A')}"
    elif reason == "reminders_ignored":
        why = f"Multiple reminders ignored for {context.get('medication_name', 'medication')}"
    else:
        why = f"Escalation needed: {reason}"
    
    escalation_id = escalation_handler.create_escalation(
        user_id=user_id,
        reason=reason,
        severity=severity,
        context=context
    )
    
    if target == "doctor":
        success = escalation_handler.escalate_to_doctor(user_id, escalation_id)
        what = f"Escalated to doctor (ID: {escalation_id})"
    else:
        caregiver_id = context.get("caregiver_id")
        success = escalation_handler.escalate_to_caregiver(user_id, escalation_id, caregiver_id)
        what = f"Escalated to caregiver (ID: {escalation_id})"
    
    return {
        "type": "ESCALATE",
        "status": "success" if success else "failed",
        "what": what,
        "why": why,
        "escalation_id": escalation_id,
        "severity": severity,
        "target": target,
        "timestamp": datetime.now().isoformat()
    }

def _execute_reorder_action(user_id: str, action: Dict, reorder_agent: ReorderAgent) -> Dict:
    """
    Execute a REORDER action.
    
    Logs:
    - what: Reorder initiated for medication X
    - why: Inventory below threshold (Y days remaining)
    """
    medication = action.get("medication", {})
    current_quantity = action.get("current_quantity", 0)
    threshold = action.get("threshold", 10)
    
    reorder_decision = reorder_agent.decide_reorder(
        user_id=user_id,
        medication=medication,
        current_quantity=current_quantity
    )
    
    if reorder_decision["should_reorder"]:
        reorder_request = reorder_agent.create_reorder_request(
            user_id=user_id,
            medication=medication,
            quantity=reorder_decision["suggested_quantity"]
        )
        
        return {
            "type": "REORDER",
            "status": "success",
            "what": f"Reorder initiated for {medication.get('name', 'medication')}",
            "why": f"Inventory below threshold ({current_quantity} remaining, threshold: {threshold})",
            "medication_id": medication.get("id"),
            "current_quantity": current_quantity,
            "reorder_quantity": reorder_decision["suggested_quantity"],
            "reorder_id": reorder_request.get("reorder_id"),
            "timestamp": datetime.now().isoformat()
        }
    else:
        return {
            "type": "REORDER",
            "status": "skipped",
            "what": f"Reorder not needed for {medication.get('name', 'medication')}",
            "why": f"Inventory sufficient ({current_quantity} remaining)",
            "medication_id": medication.get("id"),
            "current_quantity": current_quantity,
            "timestamp": datetime.now().isoformat()
        }

# Legacy support - maintain backward compatibility
def action_node(state: AgentState) -> AgentState:
    """
    Legacy action node - calls execute_actions internally.
    Maintained for backward compatibility.
    """
    return execute_actions(state)
